<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>xelo2.api.backend API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xelo2.api.backend</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from logging import getLogger
from pathlib import Path

from numpy import (
    array,
    character,
    empty,
    floating,
    isnan,
    NaN,
    issubdtype,
    )
from PyQt5.QtSql import QSqlQuery
from PyQt5.QtCore import QVariant
import sip

from .utils import (
    collect_columns,
    get_dtypes,
    out_date,
    out_datetime,
    )

lg = getLogger(__name__)


class Table():
    &#34;&#34;&#34;General class to handle one row in a SQL table. End users should not
    use this class but only its subclasses.

    Parameters
    ----------
    db : instance of QSqlDatabase
        currently open database
    id : int
        row index for an unspecified table
    &#34;&#34;&#34;
    db = None  # instance of database
    t = &#39;&#39;
    columns = {}

    def __init__(self, db, id):
        self.db = db
        self.id = id

        # check if it exists at all
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#39;SELECT id FROM {self.t}s WHERE id = :id&#39;)
        query.bindValue(&#39;:id&#39;, id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())
        if not query.next():
            raise ValueError(f&#39;Could not find id = {id} in table {self.t}s&#39;)

        self.columns = collect_columns(self.db, self.t)

    def __str__(self):
        return f&#39;&lt;{self.t} (#{self.id})&gt;&#39;

    def __repr__(self):
        return f&#39;{self.t.capitalize()}(db, id={self.id})&#39;

    def __eq__(self, other):
        &#34;&#34;&#34;So that we can compare instances very easily with set&#34;&#34;&#34;
        return self.t == other.t and self.id == other.id

    def __hash__(self):
        &#34;&#34;&#34;So that we can compare instances very easily with set&#34;&#34;&#34;
        return hash(self.__str__())

    def delete(self):
        &#34;&#34;&#34;Delete current item / this row from this table. It does not delete
        the python object.
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;DELETE FROM {self.t}s WHERE id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        self.id = None

    def __getattr__(self, key):

        if key not in self.columns:
            raise ValueError(f&#39;{key} is not stored in this {self.t}&#39;)

        table_name = self.columns[key]
        id_name = &#39;id&#39;
        if table_name != (self.t + &#39;s&#39;):  # for subtables, use foreign key
            id_name = f&#39;{self.t}_id&#39;

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;SELECT {key} FROM {table_name} WHERE {id_name} = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)

        if not query.exec():
            raise SyntaxError(query.lastError().text())

        # we need to use QVariant, because QMYSQL in PyQt5 does not distinguish between null and 0.0
        # see https://www.riverbankcomputing.com/static/Docs/PyQt5/pyqt_qvariant.html
        autoconversion = sip.enableautoconversion(QVariant, False)
        if query.next():
            out = query.value(key)

            if out.isNull():
                out = None

            elif self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDateTime&#39;:
                out = out_datetime(self.db[&#39;db&#39;].driverName(), out.value())

            elif self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDate&#39;:
                out = out_date(self.db[&#39;db&#39;].driverName(), out.value())

            else:
                out = out.value()
        else:
            lg.warning(f&#34;Could not get {key} from {table_name} for id = &#39;{self.id}&#39;&#34;)
            out = None

        sip.enableautoconversion(QVariant, autoconversion)
        return out

    def __setattr__(self, key, value):
        &#34;&#34;&#34;Set a value for a key at this row.
        Note that __setattr__ has precedence over all other attributes, so we need
        to make sure that important attributes are handled correctly by the
        subclasses.

        Notes
        -----
        Order in python:
        1. __getattribute__ and __setattr__
        2. Data descriptors, like property
        3. Instance variables from the object&#39;s __dict__ (when setting an attribute, the search ends here)
        4. Non-Data descriptors (like methods) and other class variables
        5. __getattr__
        &#34;&#34;&#34;
        BUILTINS = (
            &#39;db&#39;,
            &#39;id&#39;,
            &#39;t&#39;,
            &#39;columns&#39;,
            &#39;experimenters&#39;,
            &#39;codes&#39;,
            &#39;subject&#39;,
            &#39;session&#39;,
            &#39;run&#39;,
            &#39;events&#39;,
            &#39;data&#39;,
            &#39;intendedfor&#39;,
            &#39;_tb_data&#39;,
            &#39;__class__&#39;,
            )

        if key in BUILTINS:
            &#34;&#34;&#34;__setattr__ comes first: https://stackoverflow.com/a/15751159&#34;&#34;&#34;
            super().__setattr__(key, value)
            return

        if key not in self.columns:
            raise ValueError(f&#39;{key} is not stored in this {self.t}&#39;)

        table_name = self.columns[key]
        id_name = &#39;id&#39;
        if table_name != (self.t + &#39;s&#39;):  # for subtables, use foreign key
            id_name = f&#39;{self.t}_id&#39;

        if self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDate&#39;:
            value = _date(value)
        elif self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDateTime&#39;:
            value = _datetime(value)
        else:
            value = _null(value)

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;UPDATE {table_name} SET `{key}` = {value} WHERE {id_name} = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)

        if not query.exec():
            print(value)
            raise ValueError(query.lastError().text())


class Table_with_files(Table):
    &#34;&#34;&#34;This class (which should be used by end-users) is useful when handling
    objects which might be associated with files.
    &#34;&#34;&#34;
    def list_files(self):
        &#34;&#34;&#34;List all the files associated with this object
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;SELECT file_id FROM {self.t}s_files WHERE {self.t}_id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        out = []
        while query.next():
            out.append(File(self.db, query.value(&#39;file_id&#39;)))
        return out

    def add_file(self, format, path):
        &#34;&#34;&#34;Add a file to this object.

        Parameters
        ----------
        format : str
            type of file (list of acceptable formats is stored in &#34;allowed_values&#34;
        path : str or Path
            path of the file (it does not need to exist)
        &#34;&#34;&#34;
        path = Path(path).resolve()

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(&#34;SELECT id, format FROM files WHERE path = :path&#34;)
        query.bindValue(&#39;:path&#39;, str(path))
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        if query.next():
            file_id = query.value(&#39;id&#39;)
            format_in_table = query.value(&#39;format&#39;)

            if format != format_in_table:
                raise ValueError(f&#39;Input format &#34;{format}&#34; does not match the format &#34;{format_in_table}&#34; in the table for {path}&#39;)

        else:
            query = QSqlQuery(self.db[&#39;db&#39;])
            query.prepare(&#34;INSERT INTO files (`format`, `path`) VALUES (:format, :path)&#34;)
            query.bindValue(&#39;:format&#39;, format)
            query.bindValue(&#39;:path&#39;, str(path))
            if not query.exec():
                raise SyntaxError(query.lastError().text())

            file_id = query.lastInsertId()

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;INSERT INTO {self.t}s_files (`{self.t}_id`, `file_id`) VALUES (:id, :file_id)&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        query.bindValue(&#39;:file_id&#39;, file_id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        return File(db=self.db, id=file_id)

    def delete_file(self, file):
        &#34;&#34;&#34;There should be a trigger that deletes the file when there are no pointers anymore
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;DELETE FROM {self.t}s_files WHERE {self.t}_id = :id AND file_id = :file_id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        query.bindValue(&#39;:file_id&#39;, file.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())


class NumpyTable(Table_with_files):
    &#34;&#34;&#34;Note that self.id points to the ID of the group
    &#34;&#34;&#34;

    def __init__(self, db, id):
        super().__init__(db, id)
        self._tb_data = self.t.split(&#39;_&#39;)[0] + &#39;s&#39;

    @property
    def data(self):
        dtypes = get_dtypes(self.db[&#39;tables&#39;][self._tb_data])
        query_str = &#34;, &#34;.join(f&#34;`{col}`&#34; for col in dtypes.names)
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;SELECT {query_str} FROM {self._tb_data} WHERE {self.t}_id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        autoconversion = sip.enableautoconversion(QVariant, False)
        values = []
        while query.next():
            row = []
            for name in dtypes.names:
                v = query.value(name)
                if issubdtype(dtypes[name].type, floating) and v.isNull():
                    row.append(NaN)
                else:
                    row.append(v.value())

            values.append(tuple(row))

        sip.enableautoconversion(QVariant, autoconversion)
        return array(values, dtype=dtypes)

    @data.setter
    def data(self, values):
        &#34;&#34;&#34;If values is None, it deletes all the events.
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;DELETE FROM {self._tb_data} WHERE {self.t}_id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        if values is None:
            return

        for row in values:
            column_str, values_str = _create_query(row)
            query = QSqlQuery(self.db[&#39;db&#39;])  # column_str depends on values as well (no column when value is NaN)
            sql_cmd = f&#34;&#34;&#34;\
                INSERT INTO {self._tb_data} (`{self.t}_id`, {column_str})
                VALUES (&#39;{self.id}&#39;, {values_str})
                &#34;&#34;&#34;
            if not query.exec(sql_cmd):
                raise ValueError(query.lastError().text())

    def empty(self, n_rows):
        &#34;&#34;&#34;convenience function to get an empty array with empty values if
        necessary&#34;&#34;&#34;
        dtypes = get_dtypes(self.db[&#39;tables&#39;][self._tb_data])

        values = empty(n_rows, dtype=dtypes)
        for name in values.dtype.names:
            if issubdtype(dtypes[name].type, floating):
                values[name].fill(NaN)

        return values


class File(Table):
    t = &#39;file&#39;

    def __init__(self, db, id):
        super().__init__(db, id)

    @property
    def path(self):
        return Path(self.__getattr__(&#39;path&#39;)).resolve()


def _null(s):
    if s is None:
        return &#39;null&#39;
    else:
        s = str(s).replace(&#34;&#39;&#34;, &#39;&#34;&#39;)
        s = s.replace(&#39;\\&#39;, &#39;&#34;&#39;)
        return f&#34;&#39;{s}&#39;&#34;


def _date(s):
    if s is None:
        return &#39;null&#39;
    else:
        return f&#39;&#34;{s:%Y-%m-%d}&#34;&#39;


def _datetime(s):
    if s is None:
        return &#39;null&#39;
    else:
        return &#39;&#34;&#39; + f&#39;{s:%Y-%m-%dT%H:%M:%S.%f}&#39;[:-3] + &#39;&#34;&#39;


def _create_query(row):
    &#34;&#34;&#34;discard nan and create query strings&#34;&#34;&#34;
    dtypes = row.dtype
    columns = []
    values = []
    for name in dtypes.names:
        if issubdtype(dtypes[name].type, floating):
            if not isnan(row[name]):
                columns.append(name)
                values.append(f&#34;&#39;{row[name]}&#39;&#34;)
        elif issubdtype(dtypes[name].type, character):
            if row[name] != &#39;&#39;:
                columns.append(name)
                values.append(f&#34;&#39;{row[name]}&#39;&#34;)
        else:
            raise ValueError(f&#39;Unknown dtype {dtypes[name]}&#39;)

        assert &#39;name&#39; in columns

    columns_str = &#39;, &#39;.join([f&#39;`{x}`&#39; for x in columns])
    values_str = &#39;, &#39;.join(values)

    return columns_str, values_str</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="xelo2.api.backend.File"><code class="flex name class">
<span>class <span class="ident">File</span></span>
<span>(</span><span>db, id)</span>
</code></dt>
<dd>
<div class="desc"><p>General class to handle one row in a SQL table. End users should not
use this class but only its subclasses.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>instance</code> of <code>QSqlDatabase</code></dt>
<dd>currently open database</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>row index for an unspecified table</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class File(Table):
    t = &#39;file&#39;

    def __init__(self, db, id):
        super().__init__(db, id)

    @property
    def path(self):
        return Path(self.__getattr__(&#39;path&#39;)).resolve()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xelo2.api.backend.Table" href="#xelo2.api.backend.Table">Table</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xelo2.api.backend.File.t"><code class="name">var <span class="ident">t</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="xelo2.api.backend.File.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self):
    return Path(self.__getattr__(&#39;path&#39;)).resolve()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="xelo2.api.backend.Table" href="#xelo2.api.backend.Table">Table</a></b></code>:
<ul class="hlist">
<li><code><a title="xelo2.api.backend.Table.delete" href="#xelo2.api.backend.Table.delete">delete</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="xelo2.api.backend.NumpyTable"><code class="flex name class">
<span>class <span class="ident">NumpyTable</span></span>
<span>(</span><span>db, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Note that self.id points to the ID of the group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumpyTable(Table_with_files):
    &#34;&#34;&#34;Note that self.id points to the ID of the group
    &#34;&#34;&#34;

    def __init__(self, db, id):
        super().__init__(db, id)
        self._tb_data = self.t.split(&#39;_&#39;)[0] + &#39;s&#39;

    @property
    def data(self):
        dtypes = get_dtypes(self.db[&#39;tables&#39;][self._tb_data])
        query_str = &#34;, &#34;.join(f&#34;`{col}`&#34; for col in dtypes.names)
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;SELECT {query_str} FROM {self._tb_data} WHERE {self.t}_id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        autoconversion = sip.enableautoconversion(QVariant, False)
        values = []
        while query.next():
            row = []
            for name in dtypes.names:
                v = query.value(name)
                if issubdtype(dtypes[name].type, floating) and v.isNull():
                    row.append(NaN)
                else:
                    row.append(v.value())

            values.append(tuple(row))

        sip.enableautoconversion(QVariant, autoconversion)
        return array(values, dtype=dtypes)

    @data.setter
    def data(self, values):
        &#34;&#34;&#34;If values is None, it deletes all the events.
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;DELETE FROM {self._tb_data} WHERE {self.t}_id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        if values is None:
            return

        for row in values:
            column_str, values_str = _create_query(row)
            query = QSqlQuery(self.db[&#39;db&#39;])  # column_str depends on values as well (no column when value is NaN)
            sql_cmd = f&#34;&#34;&#34;\
                INSERT INTO {self._tb_data} (`{self.t}_id`, {column_str})
                VALUES (&#39;{self.id}&#39;, {values_str})
                &#34;&#34;&#34;
            if not query.exec(sql_cmd):
                raise ValueError(query.lastError().text())

    def empty(self, n_rows):
        &#34;&#34;&#34;convenience function to get an empty array with empty values if
        necessary&#34;&#34;&#34;
        dtypes = get_dtypes(self.db[&#39;tables&#39;][self._tb_data])

        values = empty(n_rows, dtype=dtypes)
        for name in values.dtype.names:
            if issubdtype(dtypes[name].type, floating):
                values[name].fill(NaN)

        return values</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xelo2.api.backend.Table_with_files" href="#xelo2.api.backend.Table_with_files">Table_with_files</a></li>
<li><a title="xelo2.api.backend.Table" href="#xelo2.api.backend.Table">Table</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xelo2.api.frontend.Channels" href="frontend.html#xelo2.api.frontend.Channels">Channels</a></li>
<li><a title="xelo2.api.frontend.Electrodes" href="frontend.html#xelo2.api.frontend.Electrodes">Electrodes</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="xelo2.api.backend.NumpyTable.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    dtypes = get_dtypes(self.db[&#39;tables&#39;][self._tb_data])
    query_str = &#34;, &#34;.join(f&#34;`{col}`&#34; for col in dtypes.names)
    query = QSqlQuery(self.db[&#39;db&#39;])
    query.prepare(f&#34;SELECT {query_str} FROM {self._tb_data} WHERE {self.t}_id = :id&#34;)
    query.bindValue(&#39;:id&#39;, self.id)
    if not query.exec():
        raise SyntaxError(query.lastError().text())

    autoconversion = sip.enableautoconversion(QVariant, False)
    values = []
    while query.next():
        row = []
        for name in dtypes.names:
            v = query.value(name)
            if issubdtype(dtypes[name].type, floating) and v.isNull():
                row.append(NaN)
            else:
                row.append(v.value())

        values.append(tuple(row))

    sip.enableautoconversion(QVariant, autoconversion)
    return array(values, dtype=dtypes)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xelo2.api.backend.NumpyTable.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, n_rows)</span>
</code></dt>
<dd>
<div class="desc"><p>convenience function to get an empty array with empty values if
necessary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty(self, n_rows):
    &#34;&#34;&#34;convenience function to get an empty array with empty values if
    necessary&#34;&#34;&#34;
    dtypes = get_dtypes(self.db[&#39;tables&#39;][self._tb_data])

    values = empty(n_rows, dtype=dtypes)
    for name in values.dtype.names:
        if issubdtype(dtypes[name].type, floating):
            values[name].fill(NaN)

    return values</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="xelo2.api.backend.Table_with_files" href="#xelo2.api.backend.Table_with_files">Table_with_files</a></b></code>:
<ul class="hlist">
<li><code><a title="xelo2.api.backend.Table_with_files.add_file" href="#xelo2.api.backend.Table_with_files.add_file">add_file</a></code></li>
<li><code><a title="xelo2.api.backend.Table_with_files.delete" href="#xelo2.api.backend.Table.delete">delete</a></code></li>
<li><code><a title="xelo2.api.backend.Table_with_files.delete_file" href="#xelo2.api.backend.Table_with_files.delete_file">delete_file</a></code></li>
<li><code><a title="xelo2.api.backend.Table_with_files.list_files" href="#xelo2.api.backend.Table_with_files.list_files">list_files</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="xelo2.api.backend.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>db, id)</span>
</code></dt>
<dd>
<div class="desc"><p>General class to handle one row in a SQL table. End users should not
use this class but only its subclasses.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>instance</code> of <code>QSqlDatabase</code></dt>
<dd>currently open database</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>row index for an unspecified table</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table():
    &#34;&#34;&#34;General class to handle one row in a SQL table. End users should not
    use this class but only its subclasses.

    Parameters
    ----------
    db : instance of QSqlDatabase
        currently open database
    id : int
        row index for an unspecified table
    &#34;&#34;&#34;
    db = None  # instance of database
    t = &#39;&#39;
    columns = {}

    def __init__(self, db, id):
        self.db = db
        self.id = id

        # check if it exists at all
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#39;SELECT id FROM {self.t}s WHERE id = :id&#39;)
        query.bindValue(&#39;:id&#39;, id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())
        if not query.next():
            raise ValueError(f&#39;Could not find id = {id} in table {self.t}s&#39;)

        self.columns = collect_columns(self.db, self.t)

    def __str__(self):
        return f&#39;&lt;{self.t} (#{self.id})&gt;&#39;

    def __repr__(self):
        return f&#39;{self.t.capitalize()}(db, id={self.id})&#39;

    def __eq__(self, other):
        &#34;&#34;&#34;So that we can compare instances very easily with set&#34;&#34;&#34;
        return self.t == other.t and self.id == other.id

    def __hash__(self):
        &#34;&#34;&#34;So that we can compare instances very easily with set&#34;&#34;&#34;
        return hash(self.__str__())

    def delete(self):
        &#34;&#34;&#34;Delete current item / this row from this table. It does not delete
        the python object.
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;DELETE FROM {self.t}s WHERE id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        self.id = None

    def __getattr__(self, key):

        if key not in self.columns:
            raise ValueError(f&#39;{key} is not stored in this {self.t}&#39;)

        table_name = self.columns[key]
        id_name = &#39;id&#39;
        if table_name != (self.t + &#39;s&#39;):  # for subtables, use foreign key
            id_name = f&#39;{self.t}_id&#39;

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;SELECT {key} FROM {table_name} WHERE {id_name} = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)

        if not query.exec():
            raise SyntaxError(query.lastError().text())

        # we need to use QVariant, because QMYSQL in PyQt5 does not distinguish between null and 0.0
        # see https://www.riverbankcomputing.com/static/Docs/PyQt5/pyqt_qvariant.html
        autoconversion = sip.enableautoconversion(QVariant, False)
        if query.next():
            out = query.value(key)

            if out.isNull():
                out = None

            elif self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDateTime&#39;:
                out = out_datetime(self.db[&#39;db&#39;].driverName(), out.value())

            elif self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDate&#39;:
                out = out_date(self.db[&#39;db&#39;].driverName(), out.value())

            else:
                out = out.value()
        else:
            lg.warning(f&#34;Could not get {key} from {table_name} for id = &#39;{self.id}&#39;&#34;)
            out = None

        sip.enableautoconversion(QVariant, autoconversion)
        return out

    def __setattr__(self, key, value):
        &#34;&#34;&#34;Set a value for a key at this row.
        Note that __setattr__ has precedence over all other attributes, so we need
        to make sure that important attributes are handled correctly by the
        subclasses.

        Notes
        -----
        Order in python:
        1. __getattribute__ and __setattr__
        2. Data descriptors, like property
        3. Instance variables from the object&#39;s __dict__ (when setting an attribute, the search ends here)
        4. Non-Data descriptors (like methods) and other class variables
        5. __getattr__
        &#34;&#34;&#34;
        BUILTINS = (
            &#39;db&#39;,
            &#39;id&#39;,
            &#39;t&#39;,
            &#39;columns&#39;,
            &#39;experimenters&#39;,
            &#39;codes&#39;,
            &#39;subject&#39;,
            &#39;session&#39;,
            &#39;run&#39;,
            &#39;events&#39;,
            &#39;data&#39;,
            &#39;intendedfor&#39;,
            &#39;_tb_data&#39;,
            &#39;__class__&#39;,
            )

        if key in BUILTINS:
            &#34;&#34;&#34;__setattr__ comes first: https://stackoverflow.com/a/15751159&#34;&#34;&#34;
            super().__setattr__(key, value)
            return

        if key not in self.columns:
            raise ValueError(f&#39;{key} is not stored in this {self.t}&#39;)

        table_name = self.columns[key]
        id_name = &#39;id&#39;
        if table_name != (self.t + &#39;s&#39;):  # for subtables, use foreign key
            id_name = f&#39;{self.t}_id&#39;

        if self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDate&#39;:
            value = _date(value)
        elif self.db[&#39;tables&#39;][table_name][key][&#39;type&#39;] == &#39;QDateTime&#39;:
            value = _datetime(value)
        else:
            value = _null(value)

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;UPDATE {table_name} SET `{key}` = {value} WHERE {id_name} = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)

        if not query.exec():
            print(value)
            raise ValueError(query.lastError().text())</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xelo2.api.backend.File" href="#xelo2.api.backend.File">File</a></li>
<li><a title="xelo2.api.backend.Table_with_files" href="#xelo2.api.backend.Table_with_files">Table_with_files</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="xelo2.api.backend.Table.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xelo2.api.backend.Table.db"><code class="name">var <span class="ident">db</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="xelo2.api.backend.Table.t"><code class="name">var <span class="ident">t</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="xelo2.api.backend.Table.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete current item / this row from this table. It does not delete
the python object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    &#34;&#34;&#34;Delete current item / this row from this table. It does not delete
    the python object.
    &#34;&#34;&#34;
    query = QSqlQuery(self.db[&#39;db&#39;])
    query.prepare(f&#34;DELETE FROM {self.t}s WHERE id = :id&#34;)
    query.bindValue(&#39;:id&#39;, self.id)
    if not query.exec():
        raise SyntaxError(query.lastError().text())

    self.id = None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="xelo2.api.backend.Table_with_files"><code class="flex name class">
<span>class <span class="ident">Table_with_files</span></span>
<span>(</span><span>db, id)</span>
</code></dt>
<dd>
<div class="desc"><p>This class (which should be used by end-users) is useful when handling
objects which might be associated with files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table_with_files(Table):
    &#34;&#34;&#34;This class (which should be used by end-users) is useful when handling
    objects which might be associated with files.
    &#34;&#34;&#34;
    def list_files(self):
        &#34;&#34;&#34;List all the files associated with this object
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;SELECT file_id FROM {self.t}s_files WHERE {self.t}_id = :id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        out = []
        while query.next():
            out.append(File(self.db, query.value(&#39;file_id&#39;)))
        return out

    def add_file(self, format, path):
        &#34;&#34;&#34;Add a file to this object.

        Parameters
        ----------
        format : str
            type of file (list of acceptable formats is stored in &#34;allowed_values&#34;
        path : str or Path
            path of the file (it does not need to exist)
        &#34;&#34;&#34;
        path = Path(path).resolve()

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(&#34;SELECT id, format FROM files WHERE path = :path&#34;)
        query.bindValue(&#39;:path&#39;, str(path))
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        if query.next():
            file_id = query.value(&#39;id&#39;)
            format_in_table = query.value(&#39;format&#39;)

            if format != format_in_table:
                raise ValueError(f&#39;Input format &#34;{format}&#34; does not match the format &#34;{format_in_table}&#34; in the table for {path}&#39;)

        else:
            query = QSqlQuery(self.db[&#39;db&#39;])
            query.prepare(&#34;INSERT INTO files (`format`, `path`) VALUES (:format, :path)&#34;)
            query.bindValue(&#39;:format&#39;, format)
            query.bindValue(&#39;:path&#39;, str(path))
            if not query.exec():
                raise SyntaxError(query.lastError().text())

            file_id = query.lastInsertId()

        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;INSERT INTO {self.t}s_files (`{self.t}_id`, `file_id`) VALUES (:id, :file_id)&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        query.bindValue(&#39;:file_id&#39;, file_id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        return File(db=self.db, id=file_id)

    def delete_file(self, file):
        &#34;&#34;&#34;There should be a trigger that deletes the file when there are no pointers anymore
        &#34;&#34;&#34;
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(f&#34;DELETE FROM {self.t}s_files WHERE {self.t}_id = :id AND file_id = :file_id&#34;)
        query.bindValue(&#39;:id&#39;, self.id)
        query.bindValue(&#39;:file_id&#39;, file.id)
        if not query.exec():
            raise SyntaxError(query.lastError().text())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="xelo2.api.backend.Table" href="#xelo2.api.backend.Table">Table</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="xelo2.api.backend.NumpyTable" href="#xelo2.api.backend.NumpyTable">NumpyTable</a></li>
<li><a title="xelo2.api.frontend.Protocol" href="frontend.html#xelo2.api.frontend.Protocol">Protocol</a></li>
<li><a title="xelo2.api.frontend.Recording" href="frontend.html#xelo2.api.frontend.Recording">Recording</a></li>
<li><a title="xelo2.api.frontend.Run" href="frontend.html#xelo2.api.frontend.Run">Run</a></li>
<li><a title="xelo2.api.frontend.Session" href="frontend.html#xelo2.api.frontend.Session">Session</a></li>
<li><a title="xelo2.api.frontend.Subject" href="frontend.html#xelo2.api.frontend.Subject">Subject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="xelo2.api.backend.Table_with_files.add_file"><code class="name flex">
<span>def <span class="ident">add_file</span></span>(<span>self, format, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a file to this object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>type of file (list of acceptable formats is stored in "allowed_values"</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code> or <code>Path</code></dt>
<dd>path of the file (it does not need to exist)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_file(self, format, path):
    &#34;&#34;&#34;Add a file to this object.

    Parameters
    ----------
    format : str
        type of file (list of acceptable formats is stored in &#34;allowed_values&#34;
    path : str or Path
        path of the file (it does not need to exist)
    &#34;&#34;&#34;
    path = Path(path).resolve()

    query = QSqlQuery(self.db[&#39;db&#39;])
    query.prepare(&#34;SELECT id, format FROM files WHERE path = :path&#34;)
    query.bindValue(&#39;:path&#39;, str(path))
    if not query.exec():
        raise SyntaxError(query.lastError().text())

    if query.next():
        file_id = query.value(&#39;id&#39;)
        format_in_table = query.value(&#39;format&#39;)

        if format != format_in_table:
            raise ValueError(f&#39;Input format &#34;{format}&#34; does not match the format &#34;{format_in_table}&#34; in the table for {path}&#39;)

    else:
        query = QSqlQuery(self.db[&#39;db&#39;])
        query.prepare(&#34;INSERT INTO files (`format`, `path`) VALUES (:format, :path)&#34;)
        query.bindValue(&#39;:format&#39;, format)
        query.bindValue(&#39;:path&#39;, str(path))
        if not query.exec():
            raise SyntaxError(query.lastError().text())

        file_id = query.lastInsertId()

    query = QSqlQuery(self.db[&#39;db&#39;])
    query.prepare(f&#34;INSERT INTO {self.t}s_files (`{self.t}_id`, `file_id`) VALUES (:id, :file_id)&#34;)
    query.bindValue(&#39;:id&#39;, self.id)
    query.bindValue(&#39;:file_id&#39;, file_id)
    if not query.exec():
        raise SyntaxError(query.lastError().text())

    return File(db=self.db, id=file_id)</code></pre>
</details>
</dd>
<dt id="xelo2.api.backend.Table_with_files.delete_file"><code class="name flex">
<span>def <span class="ident">delete_file</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>There should be a trigger that deletes the file when there are no pointers anymore</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_file(self, file):
    &#34;&#34;&#34;There should be a trigger that deletes the file when there are no pointers anymore
    &#34;&#34;&#34;
    query = QSqlQuery(self.db[&#39;db&#39;])
    query.prepare(f&#34;DELETE FROM {self.t}s_files WHERE {self.t}_id = :id AND file_id = :file_id&#34;)
    query.bindValue(&#39;:id&#39;, self.id)
    query.bindValue(&#39;:file_id&#39;, file.id)
    if not query.exec():
        raise SyntaxError(query.lastError().text())</code></pre>
</details>
</dd>
<dt id="xelo2.api.backend.Table_with_files.list_files"><code class="name flex">
<span>def <span class="ident">list_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List all the files associated with this object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_files(self):
    &#34;&#34;&#34;List all the files associated with this object
    &#34;&#34;&#34;
    query = QSqlQuery(self.db[&#39;db&#39;])
    query.prepare(f&#34;SELECT file_id FROM {self.t}s_files WHERE {self.t}_id = :id&#34;)
    query.bindValue(&#39;:id&#39;, self.id)
    if not query.exec():
        raise SyntaxError(query.lastError().text())

    out = []
    while query.next():
        out.append(File(self.db, query.value(&#39;file_id&#39;)))
    return out</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="xelo2.api.backend.Table" href="#xelo2.api.backend.Table">Table</a></b></code>:
<ul class="hlist">
<li><code><a title="xelo2.api.backend.Table.delete" href="#xelo2.api.backend.Table.delete">delete</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xelo2.api" href="index.html">xelo2.api</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="xelo2.api.backend.File" href="#xelo2.api.backend.File">File</a></code></h4>
<ul class="">
<li><code><a title="xelo2.api.backend.File.path" href="#xelo2.api.backend.File.path">path</a></code></li>
<li><code><a title="xelo2.api.backend.File.t" href="#xelo2.api.backend.File.t">t</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xelo2.api.backend.NumpyTable" href="#xelo2.api.backend.NumpyTable">NumpyTable</a></code></h4>
<ul class="">
<li><code><a title="xelo2.api.backend.NumpyTable.data" href="#xelo2.api.backend.NumpyTable.data">data</a></code></li>
<li><code><a title="xelo2.api.backend.NumpyTable.empty" href="#xelo2.api.backend.NumpyTable.empty">empty</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xelo2.api.backend.Table" href="#xelo2.api.backend.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="xelo2.api.backend.Table.columns" href="#xelo2.api.backend.Table.columns">columns</a></code></li>
<li><code><a title="xelo2.api.backend.Table.db" href="#xelo2.api.backend.Table.db">db</a></code></li>
<li><code><a title="xelo2.api.backend.Table.delete" href="#xelo2.api.backend.Table.delete">delete</a></code></li>
<li><code><a title="xelo2.api.backend.Table.t" href="#xelo2.api.backend.Table.t">t</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="xelo2.api.backend.Table_with_files" href="#xelo2.api.backend.Table_with_files">Table_with_files</a></code></h4>
<ul class="">
<li><code><a title="xelo2.api.backend.Table_with_files.add_file" href="#xelo2.api.backend.Table_with_files.add_file">add_file</a></code></li>
<li><code><a title="xelo2.api.backend.Table_with_files.delete_file" href="#xelo2.api.backend.Table_with_files.delete_file">delete_file</a></code></li>
<li><code><a title="xelo2.api.backend.Table_with_files.list_files" href="#xelo2.api.backend.Table_with_files.list_files">list_files</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>